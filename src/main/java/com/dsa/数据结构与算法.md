# 时间负责度大小关系
* O(1)、O(logn)、O(n)、O(nlogn)、O(n2)  

# 线性表
1. 数组
1.1. 数据为何下标从0开始？  答：以0做下表，寻找第i个元素地址计算为：a[i]_address  = base_address + i * data_type_size。可以减少一次i-1的操作。

2.  队列

3. 链表
3.1. 单链表
3.2. 双向链表
3.3. 循环链表

4. 栈






# tips
* java ArrayList 无法储存基本类型，比如int、long，需要封装为Integet，Long类，而自动装箱，拆箱有一定的性能消耗，所以如果特别关注性能，或者希望使用基本数据类型，可以考虑选用数据即可。  
* 如果数据大小事前已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组  
* 需要表示多纬数组时，数据比ArrayList更加直观。  
* java频繁的创建对象，会出现大量的垃圾回收。  


#算法
* 缓存淘汰策略
1. 先进先出策略 FIFO
2. 最少使用策略LFU（Least Frequently Used）
3. 最近最少使用策略（Least Recently Used）
3.1. 维护一个有序单链表，越靠近链表尾部的结点是越早之前的访问的，当一个新的数据被访问时   
3.2. 遍历链表删除该链表的相同结点，然后重新从头部插入  
3.3. 缓存未满时，从头插入，缓存已满，则将链表尾部结点删除。  



#后续应该练习的点
单链表反转

链表中环的检测

两个有序的链表合并

删除链表倒数第 n 个结点

求链表的中间结点